#!/usr/bin/env bash
set -euo pipefail

# agent-worktree: Simplified git worktree management with validation
# Usage:
#   agent-worktree add feat/add-gpu
#   agent-worktree remove feat/add-gpu

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

warning() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

success() {
    echo -e "${GREEN}Success: $1${NC}"
}

info() {
    echo -e "$1"
}

# Validate we're in a git repository
validate_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
    fi
}

# Check for uncommitted changes
check_uncommitted_changes() {
    if ! git diff --quiet || ! git diff --cached --quiet; then
        return 1
    fi
    return 0
}

# Check if local branch is up to date with remote
check_remote_sync() {
    git fetch --quiet origin
    
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    local upstream="origin/$current_branch"
    
    # Check if upstream exists
    if ! git rev-parse --verify "$upstream" > /dev/null 2>&1; then
        warning "No upstream branch found for $current_branch"
        return 0
    fi
    
    local local_commit=$(git rev-parse HEAD)
    local remote_commit=$(git rev-parse "$upstream")
    
    if [ "$local_commit" != "$remote_commit" ]; then
        local behind=$(git rev-list --count HEAD.."$upstream")
        local ahead=$(git rev-list --count "$upstream"..HEAD)
        
        if [ "$behind" -gt 0 ]; then
            error "Local branch is $behind commits behind remote. Please pull first."
        fi
        
        if [ "$ahead" -gt 0 ]; then
            warning "Local branch is $ahead commits ahead of remote."
        fi
    fi
}

# Get workspace root directory
get_workspace_root() {
    local git_root=$(git rev-parse --show-toplevel)
    local workspace_root=$(dirname "$git_root")
    echo "$workspace_root"
}

# Validate branch name
validate_branch_name() {
    local branch="$1"
    
    if [[ -z "$branch" ]]; then
        error "Branch name cannot be empty"
    fi
    
    # Check for invalid characters
    if ! git check-ref-format "refs/heads/$branch" 2>/dev/null; then
        error "Invalid branch name: $branch"
    fi
}

# Copy important untracked files to new worktree
copy_untracked_files() {
    local source_dir="$1"
    local dest_dir="$2"
    
    # List of files to copy if they exist
    local files_to_copy=(
        ".envrc"
        ".env"
        ".env.local"
        "secrets.json"
        "config.local.json"
    )
    
    for file in "${files_to_copy[@]}"; do
        if [ -f "$source_dir/$file" ]; then
            cp "$source_dir/$file" "$dest_dir/$file"
            info "Copied $file to new worktree"
        fi
    done
}

# Add a new worktree
add_worktree() {
    local branch="$1"
    validate_branch_name "$branch"
    
    # Check current repository state
    if ! check_uncommitted_changes; then
        error "You have uncommitted changes. Please commit or stash them first."
    fi
    
    check_remote_sync
    
    # Determine worktree path
    local workspace_root=$(get_workspace_root)
    local repo_name=$(basename "$(git rev-parse --show-toplevel)")
    local worktree_name="${branch//\//-}"  # Replace / with - in branch name
    local worktree_path="$workspace_root/$worktree_name"
    
    # Check if worktree already exists
    if [ -d "$worktree_path" ]; then
        error "Directory already exists: $worktree_path"
    fi
    
    # Check if branch already exists
    if git show-ref --quiet "refs/heads/$branch"; then
        error "Branch already exists: $branch"
    fi
    
    # Create the worktree
    info "Creating worktree at: $worktree_path"
    info "Creating branch: $branch"
    
    if ! git worktree add "$worktree_path" -b "$branch"; then
        error "Failed to create worktree"
    fi
    
    # Copy untracked files
    copy_untracked_files "$(pwd)" "$worktree_path"
    
    # Run setup scripts if they exist
    if [ -f "$worktree_path/setup.sh" ]; then
        info "Running setup.sh in new worktree..."
        (cd "$worktree_path" && bash setup.sh)
    fi
    
    success "Worktree created successfully!"
    info "To switch to the new worktree: cd $worktree_path"
}

# Remove a worktree
remove_worktree() {
    local branch="$1"
    validate_branch_name "$branch"
    
    # Find the worktree path
    local worktree_info=$(git worktree list --porcelain | grep -B2 "branch refs/heads/$branch" || true)
    
    if [ -z "$worktree_info" ]; then
        error "No worktree found for branch: $branch"
    fi
    
    local worktree_path=$(echo "$worktree_info" | grep "^worktree" | cut -d' ' -f2)
    
    if [ -z "$worktree_path" ]; then
        error "Could not determine worktree path for branch: $branch"
    fi
    
    # Check for uncommitted changes in the worktree
    if [ -d "$worktree_path" ]; then
        pushd "$worktree_path" > /dev/null
        if ! check_uncommitted_changes; then
            popd > /dev/null
            error "Worktree has uncommitted changes: $worktree_path"
        fi
        popd > /dev/null
    fi
    
    # Remove the worktree
    info "Removing worktree at: $worktree_path"
    
    if ! git worktree remove "$branch" --force; then
        error "Failed to remove worktree"
    fi
    
    # Ask if user wants to delete the branch
    read -p "Do you want to delete the branch '$branch' as well? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if git branch -d "$branch" 2>/dev/null; then
            success "Branch deleted successfully"
        else
            warning "Could not delete branch (may have unmerged changes). Use 'git branch -D $branch' to force delete."
        fi
    fi
    
    success "Worktree removed successfully!"
}

# Main command handling
main() {
    if [ $# -lt 2 ]; then
        error "Usage: agent-worktree <add|remove> <branch-name>"
    fi
    
    local command="$1"
    local branch="$2"
    
    validate_git_repo
    
    case "$command" in
        add)
            add_worktree "$branch"
            ;;
        remove)
            remove_worktree "$branch"
            ;;
        *)
            error "Unknown command: $command. Use 'add' or 'remove'"
            ;;
    esac
}

main "$@"